<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>百家樂分析器（線上版）</title>
<style>
  :root { --bg:#0f1220; --panel:#161a2e; --text:#e8ecff; --muted:#9aa3c7; --accent:#7aa2ff; }
  * { box-sizing:border-box }
  html,body{height:100%;background:var(--bg);color:var(--text);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans TC","PingFang TC","Microsoft JhengHei",Arial,sans-serif;margin:0}
  h1{font-size:1.25rem;margin:0}
  .app{max-width:1160px;margin:0 auto;padding:16px;display:grid;gap:12px}
  .row{display:grid;gap:12px}
  @media (min-width: 980px){ .row{grid-template-columns:1.15fr 0.85fr} }
  .card{background:#161a2e;border-radius:12px;padding:12px;box-shadow:0 4px 14px rgba(0,0,0,.25)}
  .card h2{font-size:1.05rem;margin:0 0 8px;color:var(--accent)}
  .toolbar{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  button{background:#1f2442;color:var(--text);border:1px solid #2b3362;border-radius:10px;padding:10px 12px;cursor:pointer}
  button:hover{background:#262c54}
  .bP{background:#1c2f5e;border-color:#2f4ea8}.bB{background:#5e1c1c;border-color:#a82f2f}.bT{background:#185d49;border-color:#2b9a7b}
  .bUndo{background:#3b2b1a;border-color:#7b5a2b}.bReset{background:#462026;border-color:#8b3b46}
  .switch{display:inline-flex;align-items:center;gap:6px;color:#9aa3c7}
  input[type="checkbox"]{width:18px;height:18px}
  select,input[type="number"],input[type="range"]{background:#10152a;color:var(--text);border:1px solid #2b3362;border-radius:8px;padding:8px}
  .stats{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  .stat{background:#12162a;border:1px solid #22294f;border-radius:10px;padding:8px}
  .stat .v{font-size:1.2rem;font-weight:700}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .roads{display:grid;grid-template-rows:auto 1fr;gap:8px;height:420px}
  .grid{background:#0c1022;border:1px solid #22294f;border-radius:10px;overflow:auto;padding:6px}
  .bigroad{display:grid;grid-auto-flow:column;grid-auto-columns:max-content;gap:2px;align-items:start}
  .col{display:grid;grid-template-rows:repeat(6,32px);gap:2px}
  .cell{width:32px;height:32px;border-radius:6px;background:#141935;display:grid;place-items:center;position:relative;border:1px solid #202851}
  .chip{width:24px;height:24px;border-radius:50%;border:2px solid rgba(255,255,255,.85)}
  .P .chip{background:#2b61ff}.B .chip{background:#ff3b3b}.T .chip{background:#00c19a}
  .pairTag{position:absolute;bottom:-2px;right:-2px;font-size:.65rem;background:rgba(255,255,255,.12);padding:0 4px;border-radius:6px;border:1px solid rgba(255,255,255,.2)}
  .gridFooter{color:#9aa3c7;font-size:.85rem;display:flex;justify-content:space-between;align-items:center}
  canvas{width:100%;height:260px;background:#0c1022;border:1px solid #22294f;border-radius:10px}
  .note{font-size:.82rem;color:#9aa3c7}
  .pill{display:inline-block;padding:4px 8px;border:1px solid #2b3362;border-radius:999px;margin-right:6px}
  hr{border:none;border-top:1px solid #2b3362;margin:10px 0}
</style>
</head>
<body>
<div class="app">
  <!-- 頂部工具 -->
  <div class="toolbar card">
    <h1>百家樂分析器（線上版）</h1>
    <div style="flex:1"></div>
    <label class="switch"><input id="savelocal" type="checkbox" checked>自動儲存</label>
    <button id="exportJson" title="匯出 JSON">匯出</button>
    <input id="importFile" style="display:none" type="file" accept=".json,application/json">
    <button id="importJson" title="匯入 JSON">匯入</button>
  </div>

  <!-- 左右主區 -->
  <div class="row">
    <!-- 左：記錄 + 大路 -->
    <div>
      <div class="card">
        <h2>快速記錄</h2>
        <div class="toolbar" style="gap:10px; margin-bottom:8px;">
          <button id="btnP" class="bP">玩家 (P)</button>
          <button id="btnB" class="bB">莊家 (B)</button>
          <button id="btnT" class="bT">和局 (T)</button>
          <span class="switch"><input id="ppair" type="checkbox">玩家對</span>
          <span class="switch"><input id="bpair" type="checkbox">莊家對</span>
          <button id="undo" class="bUndo">復原 (Z)</button>
          <button id="redo" class="bUndo">重做 (Y)</button>
          <button id="reset" class="bReset">重設</button>
        </div>
        <div class="roads">
          <div class="gridFooter">
            <div class="note">Big Road（大路）即時落子；和局疊加在上手格子，連莊/連閒自動計算。</div>
            <div class="note">快捷鍵：P/B/T、Z（復原）、Y（重做）。</div>
          </div>
          <div id="bigroad" class="grid"><div id="bigroadGrid" class="bigroad"></div></div>
        </div>
      </div>

      <!-- ★ 新卡片：放在快速記錄的正下方 -->
      <div class="card">
        <h2>下一手參考 + 對子/和機率 + 勝率預測</h2>
        <div id="nextBlock" class="mono">
          <div class="pill">當前連段：—</div>
          <div class="pill">參考：—</div>
          <div class="pill">近20手：—</div>
          <div style="margin-top:8px"></div>
          <div class="pill">莊對：—</div>
          <div class="pill">閒對：—</div>
          <div class="pill">和局：—</div>
        </div>
        <hr>
        <div class="toolbar">
          <label>預測權重（近 N 手）
            <input id="wRecent" type="range" min="0" max="100" value="50" style="vertical-align:middle">
            <span id="wLabel" class="mono">50%</span>
          </label>
          <span class="note">（其餘由理論機率補足；含 +1 平滑）</span>
        </div>
        <div id="nextProbs" class="mono" style="margin-top:6px">下一手機率估計：莊 — ｜閒 — ｜和 —</div>
        <div class="note" style="margin-top:6px">此區為統計估計與規則提示，僅供娛樂，<b>非未來保證</b>。</div>
      </div>
    </div>

    <!-- 右：統計與桌規 -->
    <div class="card">
      <h2>統計與桌規</h2>
      <div class="stats">
        <div class="stat"><div>局數</div><div id="sRounds" class="v">0</div></div>
        <div class="stat"><div>玩家勝</div><div id="sP" class="v">0</div></div>
        <div class="stat"><div>莊家勝</div><div id="sB" class="v">0</div></div>
        <div class="stat"><div>和局</div><div id="sT" class="v">0</div></div>
        <div class="stat"><div>最大連莊/閒</div><div id="sLongest" class="v mono">0 / 0</div></div>
        <div class="stat"><div>玩家對 / 莊家對</div><div id="sPairs" class="v">0 / 0</div></div>
      </div>

      <div style="margin-top:10px" class="toolbar">
        <label>牌副數
          <select id="decks">
            <option value="8" selected>8 副</option>
            <option value="6">6 副</option>
            <option value="1">1 副</option>
          </select>
        </label>
        <label>和賠率
          <select id="tiePay"><option value="8" selected>8 : 1</option><option value="9">9 : 1</option></select>
        </label>
        <label>莊規則
          <select id="bankerRule">
            <option value="commission" selected>莊 5% 抽水</option>
            <option value="no6half">免抽水（莊6半賠）</option>
          </select>
        </label>
        <label>近 N 手
          <input id="winN" type="number" min="10" max="200" step="5" value="50" style="width:90px">
        </label>
        <button id="applyRules">套用</button>
      </div>

      <div class="note" style="margin-top:8px">理論機率為常見桌規近似值；不同場館規則可能略有差異。</div>
    </div>
  </div>

  <!-- 機率面板（理論 vs 樣本） -->
  <div class="card">
    <h2>機率參考（理論 vs. 目前樣本）</h2>
    <div class="mono" id="probPanel">讀取中…</div>
  </div>

  <!-- 走勢圖 -->
  <div class="card">
    <h2>近 N 手走勢（P/B/T 比例）</h2>
    <canvas id="trend"></canvas>
  </div>

  <!-- 資料管理 -->
  <div class="card">
    <h2>資料管理</h2>
    <div class="toolbar">
      <button id="exportCSV">匯出 CSV</button>
      <button id="copyShare">複製分享連結（含資料）</button>
      <button id="clearStorage">清除本機資料</button>
    </div>
  </div>
</div>

<script>
(() => {
  // 狀態（含預測權重 wRecent）
  const state = { rounds: [], undoStack: [], redoStack: [], rules: { decks:8, tiePay:8, bankerRule:'commission', winN:50, wRecent:50 } };
  window.state = state;

  // 近似理論機率（依副數）
  const THEO_BY_DECKS = {
    8: { B:0.458597, P:0.446247, T:0.095156, PP:0.074722, BP:0.074722 },
    6: { B:0.4581,   P:0.4465,   T:0.0954,   PP:0.0746,   BP:0.0746 },
    1: { B:0.4462,   P:0.4462,   T:0.1076,   PP:0.0756,   BP:0.0756 }
  };

  // 元素
  const els = {
    sRounds:q('#sRounds'), sP:q('#sP'), sB:q('#sB'), sT:q('#sT'),
    sLongest:q('#sLongest'), sPairs:q('#sPairs'),
    bigroadGrid:q('#bigroadGrid'), ppair:q('#ppair'), bpair:q('#bpair'),
    saveLocal:q('#savelocal'), importFile:q('#importFile'),
    decks:q('#decks'), tiePay:q('#tiePay'), bankerRule:q('#bankerRule'), winN:q('#winN'),
    trend:q('#trend'), probPanel:q('#probPanel'),
    nextBlock:q('#nextBlock'), wRecent:q('#wRecent'), wLabel:q('#wLabel'), nextProbs:q('#nextProbs')
  };

  // 初始化
  loadFromHash(); loadLocal(); bindUI(); renderAll();

  // 工具
  function q(s, r=document){ return r.querySelector(s); }
  function create(tag, cls){ const e=document.createElement(tag); if(cls) e.className=cls; return e; }
  function pct(x){ return (x*100).toFixed(2)+'%'; }

  // 綁定
  function bindUI(){
    on('#btnP','click',()=>add('P')); on('#btnB','click',()=>add('B')); on('#btnT','click',()=>add('T'));
    on('#undo','click',undo); on('#redo','click',redo); on('#reset','click',resetAll);
    window.addEventListener('keydown', e=>{
      const k=e.key.toLowerCase();
      if(k==='p') add('P'); else if(k==='b') add('B'); else if(k==='t') add('T'); else if(k==='z') undo(); else if(k==='y') redo();
    });
    on('#exportJson','click', exportJSON);
    on('#importJson','click', ()=> els.importFile.click());
    els.importFile.addEventListener('change', handleImport);
    on('#exportCSV','click', exportCSV);
    on('#copyShare','click', copyShare);
    on('#clearStorage','click', ()=>{ localStorage.removeItem('baccarat_state_v1'); alert('已清除本機資料'); });

    on('#applyRules','click', ()=>{
      state.rules.decks = +els.decks.value;
      state.rules.tiePay = +els.tiePay.value;
      state.rules.bankerRule = els.bankerRule.value;
      state.rules.winN = Math.max(10, Math.min(200, +els.winN.value||50));
      saveLocal(); renderAll();
    });

    // 勝率預測：權重滑桿
    els.wRecent.addEventListener('input', ()=>{
      state.rules.wRecent = +els.wRecent.value;
      els.wLabel.textContent = state.rules.wRecent + '%';
      renderNextBlock();
      saveLocal();
    });

    function on(sel,ev,fn){ q(sel).addEventListener(ev,fn); }
  }

  // CRUD
  function add(r){
    const rec = { r, pp: !!els.ppair.checked, bp: !!els.bpair.checked, t: Date.now() };
    state.rounds.push(rec); state.undoStack.push({type:'add',rec}); state.redoStack.length=0;
    saveLocal(); renderAll();
  }
  function undo(){ if(!state.rounds.length) return; const rec=state.rounds.pop(); state.redoStack.push(rec); state.undoStack.push({type:'del',rec}); saveLocal(); renderAll(); }
  function redo(){ if(!state.redoStack.length) return; const rec=state.redoStack.pop(); state.rounds.push(rec); state.undoStack.push({type:'readd',rec}); saveLocal(); renderAll(); }
  function resetAll(){ if(!confirm('確定要重設所有記錄？')) return; state.rounds.length=0; state.undoStack.length=0; state.redoStack.length=0; saveLocal(); renderAll(); }

  // 儲存/載入
  function saveLocal(){ if(els.saveLocal.checked){ localStorage.setItem('baccarat_state_v1', JSON.stringify({rounds:state.rounds,rules:state.rules})); } }
  function loadLocal(){
    try{
      const raw=localStorage.getItem('baccarat_state_v1'); if(!raw) return;
      const obj=JSON.parse(raw);
      if(obj.rounds) state.rounds=obj.rounds;
      if(obj.rules){
        state.rules=obj.rules;
        els.decks.value=String(state.rules.decks||8);
        els.tiePay.value=String(state.rules.tiePay||8);
        els.bankerRule.value=state.rules.bankerRule||'commission';
        els.winN.value=String(state.rules.winN||50);
        els.wRecent.value=String(state.rules.wRecent||50);
        els.wLabel.textContent=(state.rules.wRecent||50)+'%';
      }
    }catch{}
  }
  function loadFromHash(){
    const h=location.hash.replace(/^#/,''); if(!h) return;
    try{
      const json=atob(decodeURIComponent(h)); const obj=JSON.parse(json);
      if(Array.isArray(obj)) state.rounds=obj;
      else if(obj && Array.isArray(obj.rounds)){ state.rounds=obj.rounds; if(obj.rules) state.rules=obj.rules; }
    }catch(e){}
  }

  // 渲染
  function renderAll(){
    // 基本統計 + 連段
    const counts={P:0,B:0,T:0,pp:0,bp:0}; let longestP=0,longestB=0; let cur=null,curLen=0;
    state.rounds.forEach(rec=>{
      counts[rec.r]++; if(rec.pp) counts.pp++; if(rec.bp) counts.bp++;
      const k=rec.r; if(k==='T') return;
      if(cur===k){ curLen++; } else { if(cur){ if(cur==='P') longestP=Math.max(longestP,curLen); else longestB=Math.max(longestB,curLen); } cur=k; curLen=1; }
    });
    if(cur){ if(cur==='P') longestP=Math.max(longestP,curLen); else longestB=Math.max(longestB,curLen); }
    q('#sRounds').textContent = state.rounds.length;
    q('#sP').textContent = counts.P; q('#sB').textContent = counts.B; q('#sT').textContent = counts.T;
    q('#sPairs').textContent = counts.pp + ' / ' + counts.bp; q('#sLongest').textContent = longestP + ' / ' + longestB;

    renderBigRoad();
    renderNextBlock();     // ← 預測/參考/對子和
    renderProbPanel();
    drawTrend();
  }

  // 大路
  function renderBigRoad(){
    const grid=q('#bigroadGrid'); grid.innerHTML='';
    const cols=[]; let col=0,row=0; let lastColor=null;
    function ensureCol(i){ while(cols.length<=i) cols.push(Array(6).fill(null)); }
    state.rounds.forEach(rec=>{
      if(rec.r==='T'){ if(col>=0){ ensureCol(col); if(row>=0 && cols[col][row]) cols[col][row].ties=(cols[col][row].ties||0)+1; } return; }
      const color=rec.r;
      if(lastColor===null){ col=0; row=0; ensureCol(col); cols[col][row]={r:color,ties:0,pp:rec.pp,bp:rec.bp}; }
      else if(color===lastColor){
        if(row<5 && !cols[col][row+1]){ row+=1; ensureCol(col); cols[col][row]={r:color,ties:0,pp:rec.pp,bp:rec.bp}; }
        else { col+=1; ensureCol(col); let r=0; while(r<6 && cols[col][r]) r++; if(r>=6){ col+=1; ensureCol(col); r=0; } row=r; cols[col][row]={r:color,ties:0,pp:rec.pp,bp:rec.bp}; }
      } else {
        col+=1; ensureCol(col); row=0; while(cols[col][0]){ col+=1; ensureCol(col); }
        cols[col][row]={r:color,ties:0,pp:rec.pp,bp:rec.bp};
      }
      lastColor=color;
    });
    cols.forEach(column=>{
      const colDiv=create('div','col');
      column.forEach(cell=>{
        const c=create('div','cell');
        if(cell){ c.classList.add(cell.r); const dot=create('div','chip'); c.appendChild(dot);
          if(cell.ties>0){ const tie=create('div','pairTag'); tie.textContent='和×'+cell.ties; tie.style.background='rgba(0,255,170,.15)'; c.appendChild(tie); }
          if(cell.pp||cell.bp){ const pair=create('div','pairTag'); pair.textContent=(cell.pp?'P':'')+(cell.bp?'B':'')+'對'; c.appendChild(pair); }
        }
        colDiv.appendChild(c);
      });
      grid.appendChild(colDiv);
    });
  }

  // ★ 下一手參考 + 對子/和 機率 + 勝率預測
  function renderNextBlock(){
    const decks = state.rules.decks;
    const theo  = THEO_BY_DECKS[decks] || THEO_BY_DECKS[8];

    // 連段（忽略和）
    let last=null,len=0;
    for(let i=state.rounds.length-1;i>=0;i--){
      const r=state.rounds[i].r; if(r==='T') continue;
      if(last===null){ last=r; len=1; } else if(r===last){ len++; } else break;
    }
    const rule = last ? (len>=2 ? `跟路（${last==='B'?'莊':'閒'} 已連 ${len}）` : `跳路（反 ${last==='B'?'莊':'閒'}）`) : '尚無';

    // 近 20 手統計（展示用）
    let P20=0,B20=0,c=0;
    for(let i=state.rounds.length-1;i>=0 && c<20;i--){
      const r=state.rounds[i].r; if(r==='P'){P20++; c++;} else if(r==='B'){B20++; c++; }
    }

    // 對子與和（理論機率）
    const html =
      `<div class="pill">當前連段：${ last ? (last==='B'?'莊':'閒')+' × '+len : '—' }</div>`+
      `<div class="pill">參考：${rule}</div>`+
      `<div class="pill">近20手：P ${P20} / B ${B20}</div>`+
      `<div style="margin-top:8px"></div>`+
      `<div class="pill">莊對（理論）：${pct(theo.BP)}</div>`+
      `<div class="pill">閒對（理論）：${pct(theo.PP)}</div>`+
      `<div class="pill">和局（理論）：${pct(theo.T)}</div>`;
    els.nextBlock.innerHTML = html;

    // 下一手機率估計（理論 × 近 N 手；+1 平滑）
    const N = state.rules.winN;
    const win = state.rounds.slice(-N);
    let eB=0,eP=0,eT=0;
    for(const r of win){ if(r.r==='B') eB++; else if(r.r==='P') eP++; else if(r.r==='T') eT++; }
    const pB_recent = (eB + 1) / (win.length + 3);
    const pP_recent = (eP + 1) / (win.length + 3);
    const pT_recent = (eT + 1) / (win.length + 3);

    const pB_theo = theo.B, pP_theo = theo.P, pT_theo = theo.T;
    const w = Math.max(0, Math.min(1, (state.rules.wRecent || 50)/100));
    let pB = w*pB_recent + (1-w)*pB_theo;
    let pP = w*pP_recent + (1-w)*pP_theo;
    let pT = w*pT_recent + (1-w)*pT_theo;
    const s = pB+pP+pT; if(s>0){ pB/=s; pP/=s; pT/=s; }

    if(els.nextProbs){
      els.nextProbs.textContent =
        `下一手機率估計：莊 ${(pB*100).toFixed(2)}% ｜閒 ${(pP*100).toFixed(2)}% ｜和 ${(pT*100).toFixed(2)}%`;
    }
  }

  // 機率面板（理論 vs 樣本 + 近視窗）
  function renderProbPanel(){
    const decks = state.rules.decks;
    const theo = THEO_BY_DECKS[decks] || THEO_BY_DECKS[8];
    const anyPairTheo = Math.min(1, theo.PP + theo.BP);

    const n = state.rounds.length;
    let cB=0,cP=0,cT=0,cBP=0,cPP=0;
    for(const r of state.rounds){ if(r.r==='B'){cB++; if(r.bp)cBP++;} else if(r.r==='P'){cP++; if(r.pp)cPP++;} else cT++; }
    const emp = { B:n?cB/n:0, P:n?cP/n:0, T:n?cT/n:0, BP:n?cBP/n:0, PP:n?cPP/n:0, ANY:n?(cBP+cPP)/n:0 };

    const N = state.rules.winN;
    const s = state.rounds.slice(-N);
    let n2=s.length, eB=0,eP=0,eT=0;
    for(const r of s){ if(r.r==='B')eB++; else if(r.r==='P')eP++; else if(r.r==='T')eT++; }
    const empWin = { B:n2?eB/n2:0, P:n2?eP/n2:0, T:n2?eT/n2:0, N };

    els.probPanel.innerHTML =
      `<div>【理論(約值)｜${decks} 副】莊 ${pct(theo.B)}｜閒 ${pct(theo.P)}｜和 ${pct(theo.T)}｜莊對 ${pct(theo.BP)}｜閒對 ${pct(theo.PP)}｜任一對 ${pct(anyPairTheo)}</div>
       <div>【樣本(全部${n}手)】莊 ${pct(emp.B)}｜閒 ${pct(emp.P)}｜和 ${pct(emp.T)}｜莊對 ${pct(emp.BP)}｜閒對 ${pct(emp.PP)}｜任一對 ${pct(emp.ANY)}</div>
       <div>【樣本(近 ${empWin.N} 手)】莊 ${pct(empWin.B)}｜閒 ${pct(empWin.P)}｜和 ${pct(empWin.T)}</div>`;
  }

  // 近 N 手走勢圖（canvas 原生，無指定色）
  function drawTrend(){
    const canvas=els.trend, ctx=canvas.getContext('2d');
    const W = canvas.width = canvas.clientWidth * devicePixelRatio;
    const H = canvas.height = canvas.clientHeight * devicePixelRatio;
    ctx.scale(devicePixelRatio, devicePixelRatio);
    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);

    const N = state.rules.winN, arr = state.rounds;
    const pts=[]; let p=0,b=0,t=0;
    for(let i=0;i<arr.length;i++){
      const r=arr[i].r; if(r==='P')p++; else if(r==='B')b++; else if(r==='T')t++;
      if(i>=N){ const old=arr[i-N].r; if(old==='P')p--; else if(old==='B')b--; else if(old==='T')t--; }
      const n=Math.min(i+1,N); pts.push({P:p/n,B:b/n,T:t/n});
    }
    const pad=18,w=canvas.clientWidth-2*pad,h=canvas.clientHeight-2*pad;
    function y(v){ return pad + (1-v)*h } function x(i){ return pad + (pts.length<=1?0:(i/(pts.length-1))*w) }
    function line(key){ ctx.beginPath(); for(let i=0;i<pts.length;i++){ const X=x(i),Y=y(pts[i][key]||0); if(i===0)ctx.moveTo(X,Y); else ctx.lineTo(X,Y) } ctx.lineWidth=2; ctx.stroke(); }
    ctx.globalAlpha=.35; ctx.beginPath(); for(let k=0;k<=5;k++){ const yy=y(k/5); ctx.moveTo(pad,yy); ctx.lineTo(pad+w,yy) } ctx.stroke(); ctx.globalAlpha=1;
    line('P'); line('B'); line('T'); ctx.fillText('P / B / T（近 N 手）', pad, pad-4);
  }

  // 匯出／匯入／分享
  function exportJSON(){ const data=JSON.stringify({rounds:state.rounds,rules:state.rules},null,2); download('baccarat_data.json',data,'application/json'); }
  function handleImport(ev){
    const f=els.importFile.files&&els.importFile.files[0]; if(!f) return;
    const reader=new FileReader(); reader.onload=e=>{
      try{ const obj=JSON.parse(String(e.target.result));
        if(Array.isArray(obj)) state.rounds=obj; else if(obj && Array.isArray(obj.rounds)){ state.rounds=obj.rounds; if(obj.rules) state.rules=obj.rules; }
        saveLocal(); renderAll(); alert('匯入完成！');
      } catch(err){ alert('讀取失敗：'+err.message); }
    }; reader.readAsText(f);
  }
  function exportCSV(){
    const header='index,time,result,player_pair,banker_pair\n';
    const rows=state.rounds.map((r,i)=>[i+1,new Date(r.t).toISOString(),r.r,r.pp?1:0,r.bp?1:0].join(','));
    const csv=header+rows.join('\n'); download('baccarat_data.csv',csv,'text/csv');
  }
  function copyShare(){
    const json=JSON.stringify({rounds:state.rounds,rules:state.rules});
    const hash=encodeURIComponent(btoa(json));
    const url=location.origin+location.pathname+'#'+hash;
    navigator.clipboard.writeText(url).then(()=>alert('已複製分享連結（資料僅存在網址中）'),()=>alert('無法複製，請手動選取網址：\n'+url));
  }
  function download(name,content,mime){ const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([content],{type:mime})); a.download=name; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),1500); }

  // 小工具
  function on(sel,ev,fn){ q(sel).addEventListener(ev,fn) }

})();
</script>
</body>
</html>
